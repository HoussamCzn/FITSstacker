#include <IUTfits.hpp>
#include <numeric>
#include <filesystem>
#include <CCfits/CCfits>

using namespace CCfits;

std::valarray<short> IUTfits::readImageData(const std::unique_ptr<FITS>& pInfile)
{
    // Reference the image data from the FITS object
    PHDU& image = pInfile->pHDU();
    // Declare a container to store image from the FITS object
    std::valarray<short> contents;
    // Copy the entire image from the FITS object into the std::valarray object contents
    image.read(contents);

    // Return the image data
    return contents;
}

void IUTfits::writeFits(const std::string& file_name, const std::unique_ptr<FITS>& base, const std::valarray<short>& contents)
{
    // Declare a FITS pointer that will store the FITS object
    std::unique_ptr<FITS> outFits;
    // Declare amount of axis arrays extracted from one of the stacked file since the dimension of the image will not change
    long naxis = base->pHDU().axes();
    // Declare axis arrays
    long* naxes = new long[naxis];

    for (size_t i = 0; i < naxis; i++)
    {
        // Fill axis arrays with the dimensions of the base FITS object
        naxes[i] = base->pHDU().axis(i);
    }

    // Check if a file with the specified file name already exists
    if (std::filesystem::exists(file_name))
    {
        // If it does, deletes it
        std::filesystem::remove(file_name);
    }

    // Reset the pointer to store a FITS object created with the specified file name, naxes and naxis defined earlier and using a SHORT default bitpix (16)
    outFits.reset(new FITS(file_name, SHORT_IMG, naxis, naxes));
    // Write comments
    outFits->pHDU().writeComment("This file was generated by FITSstacker\n");
    outFits->pHDU().writeComment("More informations in https://github.com/HoussamCzn/FITSstacker.git\n");
    // Write the date of creation of the written file
    outFits->pHDU().writeDate();
    // Write the image data contained in the given std::valarray
    outFits->pHDU().write(1, contents.size(), contents);

    // Delete the naxes array allocated with new at the beginning of this method to avoid memory leak.
    delete[] naxes;
}

std::valarray<short> IUTfits::meanStack(const std::vector<std::valarray<short>>& list)
{
    // Function at function scope to compute the mean of a std::valarray
    auto mean = [](const std::valarray<short>& arr) -> short
    {
        // Returns the sum of each array divided by the size of the array
        return std::accumulate(std::begin(arr), std::end(arr), 0) / arr.size();
    };
    // Declare a container to store each row of every data arrays, it receives its data from the tmp list
    std::vector<std::valarray<short>> contents;
    // Declare a container to store a row
    std::vector<short> tmp;
    // Declare a container to store the stacked data
    std::vector<short> res;
    // Store the "row" of the list from parameter, adding 1 to it means that we're switching array
    size_t row = 0;

    // Reserve space before adding data instead of reallocating space each time a few values are added
    contents.reserve(list[0].size());
    tmp.reserve(list.size());
    res.reserve(list[0].size());

    for (size_t j = 0; j < list[row].size(); j++)
    {
        // While there's still arrays inside the list from parameter to iterate
        while (row < list.size())
        {
            // Push the value of a case
            tmp.push_back(list[row][j]);
            // Change the iterated array to the next one
            row += 1;
        }

        // Construct inside the list storing each row a new list with the tmp data
        contents.emplace_back(tmp.data(), tmp.size());
        // Clear the current data in tmp to leave space for data from next iteration
        tmp.clear();
        // Reset to start from the first row and j+1 at next iteration
        row = 0;
    }

    for (size_t i = 0; i < contents.size(); i++)
    {
        // Push to the result list the mean of each row
        res.push_back(mean(contents[i]));
    }

    // Return a std::valarray using its contructor taking a short pointer (or array) and its size to add the result list data
    return std::valarray<short>(res.data(), res.size());
}

std::valarray<short> IUTfits::medianStack(const std::vector<std::valarray<short>>& list)
{
    // Function at function scope to compute the median of a std::valarray
    auto median = [](const std::valarray<short>& arr) -> short
    {
        const size_t& size = arr.size();

        if (size % 2 != 0)
        {
            return arr[size / 2];
        }

        return (arr[(size - 1) / 2] + arr[size / 2]) / 2;
    };
    // Declare a container to store each row of every data arrays, it receives its data from the tmp list
    std::vector<std::valarray<short>> contents;
    // Declare a container to store a row
    std::vector<short> tmp;
    // Declare a container to store the stacked data
    std::vector<short> res;
    // Store the "row" of the list from parameter, adding 1 to it means that we're switching array
    size_t row = 0;

    // Reserve space before adding data instead of reallocating space each time a few values are added
    contents.reserve(list[0].size());
    tmp.reserve(list.size());
    res.reserve(list[0].size());

    for (size_t j = 0; j < list[row].size(); j++)
    {
        // While there's still arrays inside the list from parameter to iterate
        while (row < list.size())
        {
            // Push the value of a case
            tmp.push_back(list[row][j]);
            // Change the iterated array to the next one
            row += 1;
        }

        // Sort the list to perform median calculations after
        std::sort(tmp.begin(), tmp.end());
        // Construct inside the list storing each row a new list with the tmp data
        contents.emplace_back(tmp.data(), tmp.size());
        // Clear the current data in tmp to leave space for data from next iteration
        tmp.clear();
        // Reset to start from the first row and j+1 at next iteration
        row = 0;
    }

    for (size_t i = 0; i < contents.size(); i++)
    {
        // Push to the result list the median of each row
        res.push_back(median(contents[i]));
    }

    // Return a std::valarray using its contructor taking a short pointer (or array) and its size to add the result list data
    return std::valarray<short>(res.data(), res.size());
}