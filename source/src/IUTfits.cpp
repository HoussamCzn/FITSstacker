#include <IUTfits.hpp>
#include <numeric>
#include <algorithm>
#include <filesystem>
#include <CCfits/CCfits>

using namespace CCfits;

std::valarray<short> IUTfits::readImageData(const std::unique_ptr<FITS>& pInfile)
{
    PHDU& image = pInfile->pHDU();
    std::valarray<short> contents;
    image.read(contents);

    return contents;
}

void IUTfits::writeFits(const std::string& file_name, const std::unique_ptr<FITS>& base, const std::valarray<short>& contents)
{
    std::unique_ptr<FITS> outFits;
    long naxis = base->pHDU().axes();
    long* naxes = new long[naxis];

    for (size_t i = 0; i < naxis; i++)
    {
        naxes[i] = base->pHDU().axis(i);
    }

    if (std::filesystem::exists(file_name))
    {
        std::filesystem::remove(file_name);
    }

    outFits.reset(new FITS(file_name, SHORT_IMG, naxis, naxes));
    outFits->pHDU().writeComment("This file was generated by FITSstacker\n");
    outFits->pHDU().writeComment("More informations in https://github.com/HoussamCzn/FITSstacker.git\n");
    outFits->pHDU().writeDate();
    outFits->pHDU().write(1, contents.size(), contents);

    delete[] naxes;
}

std::valarray<short> IUTfits::meanStack(const std::vector<std::valarray<short>>& list)
{
    auto mean = [](const std::valarray<short>& arr) -> short
    {
        return std::accumulate(std::begin(arr), std::end(arr), 0) / arr.size();
    };
    std::vector<std::valarray<short>> contents;
    std::vector<short> tmp;
    std::vector<short> res;
    size_t row = 0;

    contents.reserve(list[0].size());
    tmp.reserve(list.size());
    res.reserve(list[0].size());

    for (size_t j = 0; j < list[row].size(); j++)
    {
        while (row < list.size())
        {
            tmp.push_back(list[row][j]);
            row += 1;
        }

        contents.emplace_back(tmp.data(), tmp.size());
        tmp.clear();
        row = 0;
    }

    for (size_t i = 0; i < contents.size(); i++)
    {
        res.push_back(mean(contents[i]));
    }

    return std::valarray<short>(res.data(), res.size());
}

std::valarray<short> IUTfits::medianStack(const std::vector<std::valarray<short>>& list)
{
    auto median = [](const std::valarray<short>& arr) -> short
    {
        const size_t& size = arr.size();

        if (size % 2 != 0)
        {
            return arr[size / 2];
        }

        return (arr[(size - 1) / 2] + arr[size / 2]) / 2;
    };
    std::vector<std::valarray<short>> contents;
    std::vector<short> tmp;
    std::vector<short> res;
    size_t row = 0;

    contents.reserve(list[0].size());
    tmp.reserve(list.size());
    res.reserve(list[0].size());

    for (size_t j = 0; j < list[row].size(); j++)
    {
        while (row < list.size())
        {
            tmp.push_back(list[row][j]);
            row += 1;
        }

        std::sort(tmp.begin(), tmp.end());
        contents.emplace_back(tmp.data(), tmp.size());
        tmp.clear();
        row = 0;
    }

    for (size_t i = 0; i < contents.size(); i++)
    {
        res.push_back(median(contents[i]));
    }

    return std::valarray<short>(res.data(), res.size());
}